from scenedetect import SceneManager, AdaptiveDetector, open_video, video_splitter
from plexapi.myplex import MyPlexAccount
from moviepy.video.io.ffmpeg_tools import ffmpeg_extract_subclip
from moviepy.editor import VideoFileClip
from mastodon import Mastodon
import ffmpeg
import random
import os
import time
import toml
import argparse

class Bot:
    def __init__(self, config_path):
        with open(config_path, 'r') as config_file:
            self.config = toml.load(config_file)

        self.mastodon_config = self.config.get('Mastodon', {})
        self.plex_config = self.config.get('Plex', {})
        self.video_config = self.config.get('Video', {})

        self.mastodon = Mastodon(
            access_token=self.mastodon_config.get('access_token'),
            api_base_url=self.mastodon_config.get('server')
        )

        self.plex_account = MyPlexAccount(self.plex_config.get('username'), self.plex_config.get('password'))

    def find_scenes(self, video_path, threshold=3, max_duration=1400, min_duration=120, min_scene_length=600):
        video = open_video(video_path)
        scene_manager = SceneManager()
        scene_manager.add_detector(
            AdaptiveDetector(adaptive_threshold=threshold, min_scene_len=min_scene_length))
        scene_manager.detect_scenes(video)
        scene_list = scene_manager.get_scene_list()

        # Filter scenes based on duration
        filtered_scenes = [(start, end) for start, end in scene_list if ((end - start < max_duration) and (end - start > min_duration))]

        return filtered_scenes

    def cut_and_convert_scenes(self, video_path, scene_list):
        video_splitter.split_video_ffmpeg(video_path, scene_list)
        # Convert the split file to a format that Mastodon can handle
        input_file = "chapter-Scene-001.mp4"  # Replace with the actual filename generated by video_splitter
        output_file = "chapter-Scene-001_mastodon.mp4"  # Replace with your desired output filename

        (
          ffmpeg
          .input(input_file)
          .output(output_file, vcodec='libx264', acodec='aac', preset='medium')
          .run(overwrite_output=True)
        )

        os.remove(input_file)

    def get_episode(self, server, library, show):
        #plex = self.plex_account.resource(self.plex_config.get('server')).connect()
        #tv_shows = plex.library.section(self.plex_config.get('library'))
        plex = self.plex_account.resource(server).connect()
        tv_shows = plex.library.section(library)

        # Search for TV shows with content ratings including 'None', 'TV-14', 'TV-PG', 'TV-G', and 'TV-Y7'
        #range = ['TV-14', 'TV-PG', 'TV-G', 'TV-Y7']
        #pg13 = tv_shows.search(contentRating=['None'] + range)

        # Filter out shows where the first episode does not have a rating within the proper range
        #pg13 = [show for show in pg13 if show.contentRating in range or (not show.contentRating and show.episodes() and show.episodes()[0].contentRating in range)]
        show = tv_shows.get(show)
        #random_show = random.choice(pg13)
        random_episode = random.choice(show.episodes())
        #community = random.choice(tv_shows.get('Community').episodes())
        download = random_episode.download()[0]
        out = self.cut_random_chapter(download, random_episode.chapters)
        if os.path.exists(download):
            os.remove(download)
        return random_episode, out

    def cut_random_chapter(self, video_path, chapters):
        if video_path.lower().endswith('.mp4'):
            output_extension = '.mp4'
        elif video_path.lower().endswith('.mkv'):
            output_extension = '.mkv'
        else:
            raise ValueError("Unsupported file format. Only MP4 and MKV are supported.")

        if not chapters:
            # If chapters is empty, make the entire video a single chapter
            start_time = 0
            end_time = VideoFileClip(video_path).duration
            output_file = f'chapter{output_extension}'
            ffmpeg_extract_subclip(video_path, start_time, end_time, targetname=output_file)
        else:
            # If chapters is not empty, select a random chapter and extract it
            chapter = random.choice(chapters)
            start_time = chapter.start / 1000
            end_time = chapter.end / 1000
            output_file = f'chapter{output_extension}'
            ffmpeg_extract_subclip(video_path, start_time, end_time, targetname=output_file)
        return f'chapter{output_extension}'

    def process_video(self):
        while True:
            print("Getting episode")
            output = self.get_episode()
            #self.get_chapters(output)
            print("Getting scenes")
            scene_list = random.choice(self.find_scenes(output))
            print("Cutting scenes")
            self.cut_and_convert_scenes(output, [scene_list])
            print("Posting to mastodon")
            media = self.mastodon.media_post('chapter-Scene-001_mastodon.mp4')
            time.sleep(100)
            self.mastodon.status_post("test", media_ids=[media['id']])
            print("Sleeping for 30 minutes")
            time.sleep(1800)

    def process_single_video(self):
        show = self.video_config.get('show')
        server = self.plex_config.get('server')
        library = self.plex_config.get('library')

        episode, output = self.get_episode(server, library, show)

        threshold = self.video_config.get('threshold')
        max_duration = self.video_config.get('max_duration')
        min_duration = self.video_config.get('min_duration')
        min_scene_length = self.video_config.get('min_scene_length')
        scene_list = random.choice(self.find_scenes(output, threshold, max_duration, min_duration, min_scene_length))

        self.cut_and_convert_scenes(output, [scene_list])
        media = self.mastodon.media_post('chapter-Scene-001_mastodon.mp4')
        time.sleep(100) #TODO: Figure out better way to check if media was uploaded
        self.mastodon.status_post(f"Season {episode.parentIndex} Episode {episode.index}: {episode.title} ({episode.year})\n\n#Community", media_ids=[media['id']])

if __name__ == '__main__':
    # python plex.py --filename community.toml
    parser = argparse.ArgumentParser()
    parser.add_argument('--filename', default='config.toml', help='Path to the config file (default: config.toml)')
    args = parser.parse_args()
    bot = Bot(args.filename)
    bot.process_single_video()

# Usage example
#mastodon_access_token = 'pJanV9UQ8buT6ow72rm_CH6yf9n9hIeewlwJ5WFFdTc'
#mastodon_api_base_url = 'https://tomkahe.com'
#video_processor = VideoProcessor(mastodon_access_token, mastodon_api_base_url)
#video_processor.process_video()
#video_processor.process_single_video()
